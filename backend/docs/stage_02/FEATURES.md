# 第 2 阶段功能特性详解

## 🎯 核心功能

### 1. 文档加载（Document Loading）

#### 支持的格式

| 格式 | 扩展名 | 加载器 | 特点 |
|------|--------|--------|------|
| PDF | .pdf | PyPDFLoader | 支持多页文档，自动提取文本 |
| Markdown | .md, .mdx | UnstructuredMarkdownLoader | 保留格式结构 |
| 文本 | .txt | TextLoader | UTF-8 编码，简单快速 |
| HTML | .html, .htm | UnstructuredHTMLLoader | 自动清理 HTML 标签 |
| JSON | .json | JSONLoader | 支持 jq_schema 提取 |

#### 功能特性

- ✅ **单文件加载**: 加载指定的单个文档
- ✅ **目录批量加载**: 递归加载整个目录
- ✅ **格式自动检测**: 根据文件扩展名自动选择加载器
- ✅ **元数据提取**: 自动提取文件名、路径、类型等信息
- ✅ **错误处理**: 单个文件失败不影响其他文件
- ✅ **进度显示**: 批量加载时显示进度

#### 使用场景

1. **知识库构建**: 从文档目录构建知识库
2. **文档问答**: 基于文档内容回答问题
3. **内容检索**: 快速查找相关文档
4. **文档分析**: 分析文档内容和结构

### 2. 文本分块（Text Splitting）

#### 分块策略

##### RecursiveCharacterTextSplitter（推荐）

**原理**: 递归地按照分隔符（\n\n, \n, 空格等）分割文本

**优点**:
- 保持语义完整性
- 智能处理段落和句子
- 适合大多数文档类型

**适用场景**:
- 通用文档
- 长篇文章
- 技术文档

**示例**:
```python
splitter = get_text_splitter(
    splitter_type="recursive",
    chunk_size=1000,
    chunk_overlap=200
)
```

##### CharacterTextSplitter

**原理**: 按照指定的分隔符简单分割

**优点**:
- 速度快
- 简单直接

**缺点**:
- 可能破坏语义
- 不够智能

**适用场景**:
- 结构化文本
- 简单文档

##### MarkdownTextSplitter

**原理**: 按照 Markdown 的标题层级分割

**优点**:
- 保持 Markdown 结构
- 按章节分割

**适用场景**:
- Markdown 文档
- 技术文档
- 博客文章

##### TokenTextSplitter

**原理**: 基于 token 数量分割

**优点**:
- 精确控制 token 数量
- 适合 API 限制

**适用场景**:
- 需要精确控制 token
- API 有 token 限制

#### 参数调优

##### chunk_size（分块大小）

| 大小 | 适用场景 | 优点 | 缺点 |
|------|----------|------|------|
| 500 | 对话记录 | 精确检索 | 上下文不足 |
| 1000 | 通用文档 | 平衡性能和质量 | - |
| 1500 | 代码文档 | 完整上下文 | 可能有噪音 |
| 2000+ | 学术论文 | 完整段落 | 检索不精确 |

##### chunk_overlap（重叠大小）

- **推荐值**: chunk_size 的 10-20%
- **作用**: 保持跨块的上下文连续性
- **太小**: 可能丢失跨块信息
- **太大**: 冗余增加，浪费资源

#### 最佳实践

1. **根据文档类型选择策略**:
   - 通用文档 → RecursiveCharacterTextSplitter
   - Markdown → MarkdownTextSplitter
   - 精确控制 → TokenTextSplitter

2. **根据应用场景调整参数**:
   - 问答系统 → 较大的 chunk_size（1000-1500）
   - 检索系统 → 较小的 chunk_size（500-800）
   - 代码分析 → 较大的 chunk_size（1500-2000）

3. **使用重叠保持连续性**:
   - 设置 overlap 为 chunk_size 的 15-20%
   - 确保跨块信息不丢失

### 3. 向量化（Embeddings）

#### OpenAI Embeddings 模型

##### text-embedding-3-small

**规格**:
- 维度: 1536
- 价格: $0.02 / 1M tokens
- 速度: 快

**适用场景**:
- 开发测试
- 中小型项目
- 成本敏感的应用

**优点**:
- 成本低
- 速度快
- 质量足够

##### text-embedding-3-large

**规格**:
- 维度: 3072
- 价格: $0.13 / 1M tokens
- 速度: 较慢

**适用场景**:
- 生产环境
- 大型项目
- 质量优先的应用

**优点**:
- 质量高
- 表达能力强
- 检索更准确

#### 成本优化

1. **批处理**: 减少 API 调用次数
2. **缓存**: 缓存常用查询的向量
3. **选择合适的模型**: 开发用 small，生产用 large
4. **控制文档数量**: 只索引必要的文档

#### 性能优化

1. **并行处理**: 使用批处理 API
2. **异步调用**: 使用异步 API
3. **本地缓存**: 缓存 embedding 结果

### 4. 向量存储（Vector Stores）

#### FAISS（推荐）

**特点**:
- Facebook 开发的高性能向量库
- 完全本地运行
- 支持多种索引类型
- 免费开源

**优点**:
- ✅ 高性能检索
- ✅ 支持持久化
- ✅ 内存效率高
- ✅ 可扩展性好

**适用场景**:
- 中小型项目
- 本地部署
- 成本敏感

**使用示例**:
```python
from langchain_community.vectorstores import FAISS

# 创建
vector_store = FAISS.from_documents(chunks, embeddings)

# 保存
vector_store.save_local("./indexes/my_index")

# 加载
vector_store = FAISS.load_local(
    "./indexes/my_index",
    embeddings=embeddings,
    allow_dangerous_deserialization=True
)
```

#### InMemoryVectorStore

**特点**:
- 纯内存存储
- 不支持持久化
- 简单快速

**适用场景**:
- 开发测试
- 临时索引
- 快速原型

### 5. 检索（Retrieval）

#### 检索策略

##### Similarity Search（相似度检索）

**原理**: 基于余弦相似度检索最相关的文档

**优点**:
- 速度快
- 简单直接
- 适合大多数场景

**缺点**:
- 可能返回重复内容
- 缺乏多样性

**参数**:
- `k`: 返回文档数量（推荐 3-5）

**使用场景**:
- 通用问答
- 快速检索
- 精确匹配

##### MMR（最大边际相关性）

**原理**: 在相关性和多样性之间取得平衡

**优点**:
- 结果更多样化
- 避免重复内容
- 覆盖更广

**缺点**:
- 速度稍慢
- 可能牺牲相关性

**参数**:
- `k`: 返回文档数量
- `fetch_k`: 候选文档数量（推荐 k 的 3-5 倍）

**使用场景**:
- 需要多样性的场景
- 探索性查询
- 综合性问题

##### Similarity Score Threshold（阈值过滤）

**原理**: 只返回相似度超过阈值的文档

**优点**:
- 保证质量
- 过滤不相关文档

**缺点**:
- 返回数量不确定
- 可能找不到文档

**参数**:
- `score_threshold`: 相似度阈值（推荐 0.5-0.7）
- `k`: 最大返回数量

**使用场景**:
- 质量优先
- 精确查询
- 专业领域

#### 参数调优指南

| 参数 | 推荐值 | 说明 |
|------|--------|------|
| k | 3-5 | 返回文档数量 |
| score_threshold | 0.5-0.7 | 相似度阈值 |
| fetch_k | k * 3-5 | MMR 候选数量 |

### 6. RAG Agent

#### 核心特性

1. **自动检索**: Agent 自动决定何时检索
2. **上下文增强**: 用检索到的文档增强上下文
3. **来源引用**: 在回答中引用来源文档
4. **流式输出**: 支持实时流式响应
5. **对话历史**: 支持多轮对话

#### 工作流程

```
用户问题
    ↓
Agent 分析问题
    ↓
调用 retriever_tool 检索
    ↓
获取相关文档
    ↓
构建增强上下文
    ↓
生成回答
    ↓
返回回答 + 来源
```

#### 提示词设计

**系统提示词**:
```python
system_prompt = """你是一个智能问答助手。

你的任务：
1. 使用 knowledge_base 工具搜索相关信息
2. 基于检索到的文档内容回答问题
3. 如果文档中没有相关信息，诚实告知
4. 在回答中引用来源文档

回答要求：
- 准确：严格基于文档内容
- 完整：提供详细回答
- 清晰：使用简洁语言
- 引用：列出参考来源
"""
```

#### 最佳实践

1. **清晰的提示词**: 明确告诉 Agent 如何使用工具
2. **来源引用**: 要求 Agent 引用来源
3. **诚实回答**: 没有信息时诚实告知
4. **控制迭代**: 设置合理的 max_iterations

### 7. 索引管理

#### 功能特性

1. **创建索引**: 从文档创建向量索引
2. **列出索引**: 查看所有可用索引
3. **查看信息**: 获取索引详细信息
4. **更新索引**: 向现有索引添加文档
5. **删除索引**: 删除不需要的索引

#### 元数据管理

每个索引都有元数据文件（metadata.json）:
```json
{
  "name": "my_docs",
  "description": "我的文档集合",
  "created_at": "2024-01-01T00:00:00",
  "updated_at": "2024-01-01T00:00:00",
  "num_documents": 100,
  "store_type": "faiss",
  "embedding_model": "text-embedding-3-small"
}
```

#### 最佳实践

1. **使用描述性名称**: 便于识别和管理
2. **添加描述信息**: 记录索引用途
3. **定期更新**: 保持索引内容最新
4. **分类管理**: 不同类型文档用不同索引

### 8. API 接口

#### RESTful 设计

遵循 REST 原则:
- 使用标准 HTTP 方法
- 清晰的资源路径
- 统一的响应格式
- 详细的错误信息

#### 端点列表

| 方法 | 路径 | 功能 | 说明 |
|------|------|------|------|
| POST | /rag/index | 创建索引 | 从目录创建索引 |
| GET | /rag/index/list | 列出索引 | 获取所有索引 |
| GET | /rag/index/{name} | 索引信息 | 获取详细信息 |
| DELETE | /rag/index/{name} | 删除索引 | 删除指定索引 |
| POST | /rag/query | RAG 查询 | 非流式查询 |
| POST | /rag/query/stream | 流式查询 | SSE 流式响应 |
| POST | /rag/search | 纯检索 | 只检索不生成 |
| GET | /rag/health | 健康检查 | 服务状态 |

#### 流式响应（SSE）

使用 Server-Sent Events 实现流式响应:
```javascript
// 客户端示例
const eventSource = new EventSource('/rag/query/stream');

eventSource.onmessage = (event) => {
  const data = JSON.parse(event.data);
  
  if (data.type === 'content') {
    // 显示内容
    console.log(data.content);
  } else if (data.type === 'done') {
    // 完成
    eventSource.close();
  }
};
```

### 9. CLI 工具

#### 命令结构

```
rag_cli.py
├── index              # 索引管理
│   ├── create        # 创建索引
│   ├── list          # 列出索引
│   ├── info          # 查看信息
│   └── delete        # 删除索引
├── query             # RAG 查询
├── search            # 纯检索
└── interactive       # 交互模式
```

#### 特色功能

1. **Rich 美化输出**:
   - 彩色文本
   - 表格展示
   - Markdown 渲染
   - 进度条

2. **交互模式**:
   - 持续对话
   - 实时响应
   - 来源显示

3. **友好的错误提示**:
   - 清晰的错误信息
   - 解决方案建议

## 🎯 应用场景

### 1. 企业知识库

**场景**: 构建企业内部知识库，支持员工快速查询

**实现**:
- 索引公司文档（政策、流程、FAQ）
- 提供搜索和问答接口
- 集成到企业应用

### 2. 技术文档助手

**场景**: 帮助开发者快速查找技术文档

**实现**:
- 索引技术文档和 API 文档
- 提供代码示例和最佳实践
- 支持多语言文档

### 3. 客户服务

**场景**: 自动回答客户常见问题

**实现**:
- 索引产品文档和 FAQ
- 提供 24/7 自动回答
- 人工客服辅助

### 4. 学习助手

**场景**: 帮助学生学习和复习

**实现**:
- 索引教材和课程资料
- 提供问答和总结
- 生成练习题

### 5. 法律咨询

**场景**: 快速查找法律条文和案例

**实现**:
- 索引法律文档和判例
- 提供法律问答
- 引用具体条文

## 📊 性能指标

### 索引构建

| 文档数量 | 文档大小 | 构建时间 | 索引大小 |
|---------|---------|---------|---------|
| 10 | 100KB | ~10s | ~1MB |
| 100 | 1MB | ~1min | ~10MB |
| 1000 | 10MB | ~10min | ~100MB |
| 10000 | 100MB | ~2h | ~1GB |

### 查询性能

| 索引大小 | 查询时间 | 内存占用 |
|---------|---------|---------|
| 小（<100 文档） | <1s | ~50MB |
| 中（100-1000） | 1-2s | ~200MB |
| 大（>1000） | 2-5s | ~500MB |

### 成本估算

| 操作 | Token 消耗 | 成本（small） | 成本（large） |
|------|-----------|--------------|--------------|
| 索引 100 文档 | ~100K | $0.002 | $0.013 |
| 单次查询 | ~2K | $0.00004 | $0.00026 |
| 1000 次查询 | ~2M | $0.04 | $0.26 |

## 🔒 安全考虑

### 1. 数据安全

- 本地存储，数据不上传
- 支持加密存储（可扩展）
- 访问控制（可扩展）

### 2. API 安全

- 输入验证
- 错误处理
- 速率限制（可扩展）

### 3. 内容安全

- 文档来源验证
- 内容过滤（可扩展）
- 敏感信息保护

## 🚀 未来扩展

### 1. 功能扩展

- 支持更多文档格式（Word、Excel、PPT）
- 支持图片和表格提取
- 支持多语言文档
- 支持文档更新检测

### 2. 性能优化

- 分布式索引
- 缓存优化
- 并行处理
- GPU 加速

### 3. 集成扩展

- 集成更多向量库（Pinecone、Weaviate）
- 集成更多 LLM（Claude、Gemini）
- 集成企业应用（Slack、Teams）
- 提供 SDK 和插件

## 📚 总结

第 2 阶段实现了一个功能完整、性能优秀、易于使用的 RAG 系统，涵盖了从文档加载到智能问答的完整流程。通过模块化设计和丰富的配置选项，系统可以适应各种应用场景和需求。

